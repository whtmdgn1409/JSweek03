원문 : https://d2.naver.com/helloworld/5237120

렌더러 프로세스가 HTML 문서를 받았을 때 어떤 절차를 거쳐 화면을 구성하는지 설명한다.
이 과정을 효율적으로 처리하기 위해 렌더러 프로세스가 어떤 아키텍처를 가지고 있는지 살펴보고,
웹 개발자가 고려하면 좋을 내용을 소개한다.

<h2>렌더러 프로세스의 내부 동작</h2>

- 렌더러 프로세스는 여러 측면에서 웹 페이지의 성능에 영향을 끼친다.

<h2>렌더러 프로세스는 웹 콘텐츠를 처리한다.</h2>
- 렌더러 프로세스는 탭 내부에서 발생하는 모든 작업을 담당한다. 렌더러 프로세스의 메인 스레드가
브라우저로 전송된 대부분의 코드를 처리한다. 간혹 웹 워커나 서비스 워커를 사용하는 경우에는
워커 스레드가 JS 코드의 일부를 처리한다. 웹 페이지를 효율적이고 부드럽게 렌더링하기 위해
별도의 컴포지터 스레드와 래스터 스레드가 렌더러 프로세스에서 실행된다.
렌더러 프로세스의 주 역할은 HTML, CSS, JavaScript를 사용자와 상호작용할 수 있는 웹 페이지로
변환하는 것이다.

<h2>파싱</h2>

1. DOM 구축
- 페이지를 이동하는 내비게이션 실행 메시지를 렌더러 프로세스가 받고 HTML 데이터를 수신하기 시작하면
렌더러 프로세스의 메인 스레드는 문자열(HTML)을 파싱해서 DOM(Document Object Model)으로 변환한다.

DOM은 브라우저가 내부적으로 웹 페이지를 표현하는 방법일 뿐만 아니라 웹 개발자가 JS를 통해 상호작용할 수 있는
데이터 구조이자 API이다.

HTML 문서를 DOM으로 파싱하는 방법은 HTML 표준에 정의되어 있다.\

2. 하위 리소스(SubResource) 로딩
- 웹 사이트는 일반적으로 이미지, CSS, JS와 같은 외부 리소스를 사용한다. 이러한 파일은 네트워크나 캐시에서 로딩해야 한다.
DOM을 구축하기 위해 파싱하는 동안 이런 리소스를 만날 때마다 메인 스레드가 하나하나 요청할 수도 있을 것이다.
하지만 속도를 높이기 위해 "프리로드 스캐너"가 동시에 실행한다.
HTML 문서에 <img > 또는 <link>와 같은 태그가 있으면 프리로드 스캐너는 HTML 파서가 생성한 토큰을
확인하고 브라우저 프로세스의 네트워크 스레드에 요청을 보낸다.

3. 자바스크립트가 파싱을 막을 수 있다.
- <script></script>를 만나면 HTML 파서는 HTML 문서의 파싱을 일시 중지한 다음 JS 코드를 로딩하고
파싱해 실행해야 한다. 왜냐하면 JS는 DOM 구조 전체를 바꿀 수 있는 document.write() 메서드와 같은 것을 사용해
문서의 모양을 변경할 수 있기 때문이다. HTML 파싱을 재개하기 전에 HTML 파서는 JS의 실행이 끝나기를
기다려야 한다.


<h2>리소스를 로딩하는 방법에 대한 힌트를 주자</h2>
- 웹 개발자가 브라우저에 리소스 로딩에 대한 힌트를 보내는 방법에는 여러가지가 있다.
JS에서느 document.write() 메서드를 사용하지 않는다면 <script></script> 태그에
async 속성이나 defer 속성을 추가할 수 있다. 이 속성이 있으면 브라우저가 JS 코드를 비동기적으로
로딩하고 실행하면서 HTML 파싱을 막지 않는다. JS 모듈을 사용할 수도 있다.
<link rel="preload">는 현재 내비게이션을 실행하기 위해 리소스가 반드시 필요하다는 것을
브라우저에 알려서 리소스를 가능한 한 빨리 다운로드하려는 경우에 사용할 수 있다.


<h2>스타일 계산</h2>
- DOM 만으로는 웹 페이지의 모양을 알 수 없다. CSS로 웹 페이지 요소의 모양을 결정할 수 있기 때문이다.
메인 스레드는 CSS를 파싱하고 각 DOM 노드에 해당되는 계산된 스타일(Computed Style)을 확정한다.
계산된 스타일은 CSS 선택자로 구분되는 요소에 적용될 스타일에 관한 정보이다.
CSS를 전혀 적용하지 않아도 DOM 노드에는 계산된 스타일이 적용되어 있다.
<h1>h1</h1>태그는 <h2>h2</h2>태그보다 크게 표시되며
바깥 여백(margin)이 모든 요소에 적용된다. 브라우저에 기본 스타일 시트가 있기 때문이다.


<h2>레이아웃</h2>
- 레이아웃은 요소의 기하학적 속성(geometry)를 찾는 과정이다. 메인 스레드는 DOM과 계산된 스타일을
훑어가며 레이아웃 트리를 만든다. 레이아웃 트리는 x,y 좌표, 박스 영역(bounding box)의 크기와 같은 정보를 가지고 있다.
레이아웃 트리는 DOM 트리와 비슷한 구조일 수 있지만 웹 페이지에 보이는 요소에 관련된 정보만 가지고 있다.
display: none 속성이 적용된 요소는 레이아웃 트리에 포함되지 않는다.
그러나 visibility: hidden 속성이 적용된 요소는 레이아웃 트리에 포함된다.
이와 비슷하게 p::before{content: "Hi!"} 속성과 같은 의사 클래스(psedo class)의 콘텐츠는
DOM에는 포함되지 않지만 레이아웃 트리에는 포함된다.

레이아웃 트리와 다음에 설명할 페인트 트리 사이에 한 가지 작업이 더 있다.
레이아웃 트리를 순회하면서 속성 트리(property tree)를 만드는 작업이다.
속성 트리는 clip, transform, opacity등의 속성 정보만 가진 트리이다.
기존에는 이런 정보를 분리하지 않고 노드마다 가지고 있었다.
그래서 특정 노드의 속성이 변경되면 해당 노드의 하위 노드에도 이 값을 다시 반영하면서 노드를 순회해야 했다.
최신 Chrome에서는 이런 속성만 별도로 관리하고 각 노드에서는 속성 트리의 노드를 참조하는 방식으로 변경되고 있다.


<h2>페인트</h2>
- DOM에 선언된 노드 순서와 페인트 순서는 많이 다를 수 있다. 예를 들어 어떤 요소에 z-index 속성이
적용되었다면 HTML에 작성된 순서로 요소를 그리면 잘못 렌더링된 화면이 나온다.
페인트 단계에서 메인 스레드는 페인트 기록(paint record)를 생성하기 위해 레이아웃 트리를 순회한다.
페인트 기록은 페인팅 과정을 기록한 것이다.



<h2>렌더링 파이프라인을 갱신하는 데는 많은 비용이 든다.</h2>
- 렌더링 파이프라인에서 파악해야 할 가장 중요한 점은 각 단계에서 이전 작업의 결과가 새 데이터를 만드는 데 사용된다는 것이다.
예를 들어 레이아웃 트리에서 변경이 생겨 문서의 일부가 영향을 받으면 페인팅 순서도 새로 생성해야 한다.

요소에 애니메이션을 적용하면 브라우저는 모든 프레임 사이에 이러한 작업을 해야 한다.
대부분의 디스플레이 장치는 화면을 초당 60번 새로 고친다. 요소의 움직임이 모든 프레임에 반영되어야 사람이 볼 때
부드럽게 느껴진다. 애니메이션에서 프레임이 누락되면 웹 페이지가 버벅대는 것처럼 보인다.

화면 주사율에 맞추어 렌더링 작업이 이루어져도 이 작업은 메인 스레드에서 실행되기 때문에
애플리케이션이 JS를 실행하는 동안 렌더링이 막힐 수 있다.
JS 작업을 작은 덩어리로 나누고 requestAnimationFrame() 메서드를 사용해 프레임마다 실행하도록
스케줄을 관리할 수 있다.


<h2>합성</h2>
- 페이지는 어떻게 그려질까?
브라우저는 문서의 구조와 각 요소의 스타일, 요소의 기하학적 속성, 페인트 순서를 알고 있다.
브라우저는 이제 웹 페이지를 어떻게 그릴까? 이 정보를 화면의 픽셀로 변환한느 작업을 래스터화라고 한다.
가장 단순한 래스터화는 아마 뷰포트 안쪽을 래스터하는 것일 것이다. 사용자가 페이지를 스크롤하면 이미 래스터한 프레임을 움지이고 나머지 빈 부분을 추가로 래스터화한다.
그러나 최신 브라우저는 합성이라는 보다 정교한 과정을 거친다.

합성은 페이지의 각 부분을 레이어로 분리해 별도로 래스터화하고 컴포지터 스레드라고 불리는 별도의 스레드에서
웹 페이지로 합성하는 기술이다. 스크롤되었을 때 레이어는 이미 래스터화되어 있으므로 새 프레임을 합성하기만 하면 된다.
애니메이션 역시 레이어를 움직이고 합성하는 방식으로 만들 수 있다.
컴포지터 스레드를 별도로 유지하는 것이 오히려 부담이 더 클 때에는 싱글 스레드에서 합성을 실행하기도 한다. 
브라우저의 UI 부분(chrome)을 담당하는 컴포지터는 싱글 스레드로 작동한다.